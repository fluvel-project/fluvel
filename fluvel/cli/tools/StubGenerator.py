# Copyright (C) 2025-2026 J. F. Escobar
# SPDX-License-Identifier: LGPL-3.0-or-later

from datetime import datetime
from pathlib import Path
from typing import Any

# Stubs Templates
from fluvel.cli.templates.stubs import (
    MENU_BAR_TEMPLATE,
    RMANAGER_TEMPLATE,
    SETTINGS_TEMPLATE,
)

# Fluvel I18n
from fluvel.i18n.I18nLoader import I18nLoader
from fluvel.user.UserSettings import Settings

# Fluvel Paths
from fluvel.utils.paths import CONFIG_PATH, I18N_DIR, STUBS_DIR

STUBS_FOLDERS = [
    STUBS_DIR,
    STUBS_DIR / "fluvel",
    STUBS_DIR / "fluvel" / "i18n",
    STUBS_DIR / "fluvel" / "user",
    STUBS_DIR / "fluvel" / "core",
]

FILE_OUTPUTS = {
    "texts": STUBS_DIR / "fluvel" / "i18n" / "ResourceManager.pyi",
    "settings": STUBS_DIR / "fluvel" / "user" / "UserSettings.pyi",
    "menu-bar": STUBS_DIR / "fluvel" / "core" / "MenuBar.pyi",
}


class SafeDict(dict):
    def __missing__(self, key: str) -> str:
        return ""


def flatten_keys(d: dict[str, Any], prefix: str = "") -> set[str]:
    """
    Returns a set containing all configuration keys in dot notation format
    """

    keys = set()

    for k, v in d.items():
        # We construct the current key by concatenating the prefix
        current_key = f"{prefix}.{k}" if prefix else k

        if isinstance(v, dict):
            # If it's a dictionary, we go down one level.
            keys.update(flatten_keys(v, current_key))
        else:
            # If it's a final value, we add it to the set
            keys.add(current_key)
    return keys


def flatten_menu_keys(d: dict[str, Any], prefix: str = "") -> set[str]:
    keys = set()

    if not isinstance(d, dict):
        return keys

    for k, v in d.items():
        # Separators are ignored
        if k.startswith("sep_"):
            continue

        # We construct the current key by concatenating the prefix
        current_key = f"{prefix}.{k}" if prefix else k

        # Add the current key to the set (Actions only)
        if not v.get("elements"):
            keys.add(current_key)

        # If it's a dictionary, we go down one level.
        if elements := v.get("elements"):
            keys.update(flatten_menu_keys(elements, current_key))

    return keys


class StubGen:
    @staticmethod
    def generate_stubs():
        if not CONFIG_PATH.exists():
            return

        Settings.init_config(CONFIG_PATH)

        StubGen.create_stub_folders()

        StubGen.generate_i18n_stubs()
        StubGen.generate_settings_stub()

    @staticmethod
    def create_stub_folders() -> None:
        for folder in STUBS_FOLDERS:
            folder.mkdir(parents=True, exist_ok=True)

    @staticmethod
    def __generate_i18n_stubs() -> None:
        """
        unused: iterates over all language directories to extract 
        the keys and generate a set[str] of them.
        """

        text_stubs: set[str] = set()
        menu_stubs: set[str] = set()

        for f in I18N_DIR.iterdir():
            if not f.is_dir():
                continue

            raw = I18nLoader.load(f.name, False)

            text_stubs |= raw.TEXTS.keys()
            menu_stubs |= flatten_menu_keys(raw.MENUS.get("main-menu", {}))

    @staticmethod
    def generate_i18n_stubs():
        raw = I18nLoader.load(Settings.ui.language, False)

        text_keys: set[str] = raw.TEXTS.keys()
        menu_bar_keys: set[str] = flatten_menu_keys(raw.MENUS.get("main-menu", {}))

        StubGen.write_stub("I18nKeys", RMANAGER_TEMPLATE, text_keys, FILE_OUTPUTS["texts"])
        StubGen.write_stub(
            "MenuBarKeys", MENU_BAR_TEMPLATE, menu_bar_keys, FILE_OUTPUTS["menu-bar"]
        )

    @staticmethod
    def generate_settings_stub():
        keys: set[str] = flatten_keys(Settings.dict_tree)
        StubGen.write_stub("SettingsKeys", SETTINGS_TEMPLATE, keys, FILE_OUTPUTS["settings"])

    @staticmethod
    def _build_literal(keys: set[str]) -> str:
        formatted_keys = ",\n\t".join(f'"{k}"' for k in sorted(keys)) or '""'
        return f"Literal[\n\t{formatted_keys}\n]"

    @staticmethod
    def _build_stub(template: str, **replacements) -> str:
        return template.format_map(SafeDict(replacements))

    @staticmethod
    def write_stub(literal_name: str, template: str, keys: set[str], filepath: Path) -> None:
        header = f"# Autogenerated file: {datetime.now()} \n"
        literal = StubGen._build_literal(keys)
        content = StubGen._build_stub(template, name=literal_name, literal=literal, header=header)

        filepath.write_text(content, encoding="utf-8")
